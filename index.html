<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Field Coordinate Meter</title>
  <style>
    :root {
      --bg-1: #e9f1ff;
      --bg-2: #cddff9;
      --card: #ffffff;
      --text: #0f1e33;
      --muted: #395575;
      --accent: #0077ff;
      --accent-2: #00a39b;
      --surface: #f2f7ff;
      --surface-border: #c2d4ec;
      --control-border: #9eb9da;
      --line: rgba(15, 30, 51, 0.28);
      --shadow: 0 12px 28px rgba(15, 30, 51, 0.18);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Segoe UI", Tahoma, sans-serif;
      color: var(--text);
      background: radial-gradient(circle at 12% 12%, var(--bg-2), var(--bg-1) 55%);
      padding: 18px;
    }

    .app {
      width: min(96vw, 1500px);
      max-width: 1500px;
      margin: 0 auto;
      background: var(--card);
      border: 1px solid var(--surface-border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 16px;
    }

    .workspace {
      display: grid;
      grid-template-columns: max-content clamp(260px, 28vw, 420px);
      gap: 8px;
      align-items: start;
      justify-content: center;
    }

    .left-col {
      width: fit-content;
      --board-max: clamp(300px, 44vw, 560px);
    }

    .right-col {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .stat {
      background: var(--surface);
      border: 1px solid var(--surface-border);
      border-radius: 10px;
      padding: 9px 11px;
      font-variant-numeric: tabular-nums;
      min-width: 0;
    }

    .label {
      color: var(--muted);
      font-size: 0.78rem;
      margin-bottom: 3px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 600;
    }

    .value {
      color: var(--text);
      font-weight: 700;
    }

    .control {
      background: var(--surface);
      border: 1px solid var(--surface-border);
      border-radius: 10px;
      padding: 9px 11px;
    }

    .control .label {
      display: block;
      margin-bottom: 5px;
    }

    select {
      border: 1px solid var(--control-border);
      border-radius: 8px;
      padding: 6px 9px;
      background: #fff;
      color: var(--text);
      font-size: 0.9rem;
      font-weight: 500;
    }

    .control select {
      width: 100%;
    }

    .control-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .board {
      position: relative;
      width: var(--board-max);
      max-width: 100%;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid #b8cde8;
      background: #e2ecfb;
      line-height: 0;
      touch-action: none;
      user-select: none;
    }

    .board img {
      width: 100%;
      height: auto;
      display: block;
      user-select: none;
      -webkit-user-drag: none;
    }

    .wall-overlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    .inner-wall-path {
      stroke: #000;
      fill: none;
      vector-effect: non-scaling-stroke;
      stroke-linejoin: miter;
    }

    .obstacle-boundary-line {
      stroke: #d100c9;
      fill: none;
      vector-effect: non-scaling-stroke;
      stroke-linecap: butt;
    }

    .cross {
      position: absolute;
      pointer-events: none;
      opacity: 0;
      transition: opacity 120ms ease;
      z-index: 4;
    }

    .cross.show {
      opacity: 1;
    }

    .cross.v {
      width: 2px;
      top: 0;
      bottom: 0;
      transform: translateX(-50%);
      background: rgba(0, 119, 255, 0.72);
    }

    .cross.h {
      height: 2px;
      left: 0;
      right: 0;
      transform: translateY(-50%);
      background: rgba(0, 119, 255, 0.72);
    }

    .lines-layer {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 2;
    }

    .point-link {
      stroke: rgba(22, 33, 49, 0.42);
      stroke-width: 1;
      fill: none;
      vector-effect: non-scaling-stroke;
    }

    .points-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 3;
    }

    .start-zone-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 5;
    }

    .start-zone-rect {
      position: absolute;
      border: none;
      background: rgba(255, 235, 59, 0.16);
      border-radius: 6px;
    }

    .start-dir-arrow {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 18px;
      height: 10px;
      background: rgba(210, 25, 25, 0.95);
      clip-path: polygon(0 25%, 72% 25%, 72% 0, 100% 50%, 72% 100%, 72% 75%, 0 75%);
      transform: translate(-50%, -50%) rotate(0deg);
    }

    .single-traffic-sign {
      position: absolute;
      transform: translate(-50%, -50%);
      border-radius: 2px;
      border: none;
      box-shadow: none;
      display: none;
    }

    .single-traffic-sign.red {
      background: #e53935;
    }

    .single-traffic-sign.green {
      background: #1ea653;
    }

    .point-marker {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid #fff;
      background: var(--accent-2);
      margin: -6px 0 0 -6px;
      box-shadow: 0 0 0 2px rgba(0, 163, 155, 0.35);
    }

    .point-marker.latest {
      background: #ff7a00;
      box-shadow: 0 0 0 2px rgba(255, 122, 0, 0.35);
    }

    .point-index {
      position: absolute;
      min-width: 16px;
      height: 16px;
      padding: 0 4px;
      border-radius: 999px;
      background: rgba(22, 33, 49, 0.88);
      color: #fff;
      font-size: 10px;
      line-height: 16px;
      font-weight: 700;
      text-align: center;
      transform: translate(8px, -12px);
      white-space: nowrap;
    }

    .size-mode {
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .size-buttons {
      display: inline-flex;
      gap: 8px;
    }

    .size-btn {
      min-width: 40px;
      border: 1px solid var(--control-border);
      border-radius: 8px;
      padding: 5px 10px;
      background: #fff;
      color: var(--text);
      cursor: pointer;
      font-size: 0.88rem;
      font-weight: 600;
    }

    .size-btn.active {
      background: #dbeafe;
      border-color: #6ea2de;
      color: #0b438f;
    }

    .points-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 6px;
    }

    .points-count {
      font-size: 0.84rem;
      color: var(--muted);
      font-variant-numeric: tabular-nums;
    }

    .clear-btn {
      border: 1px solid var(--control-border);
      border-radius: 8px;
      background: #fff;
      color: var(--text);
      cursor: pointer;
      font-size: 0.82rem;
      padding: 4px 10px;
    }

    .points-list {
      margin: 0;
      padding-left: 18px;
      max-height: 180px;
      overflow: auto;
      font-size: 0.86rem;
      line-height: 1.4;
    }

    .points-list li {
      margin: 0 0 4px;
      font-variant-numeric: tabular-nums;
    }

    .wall-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 8px;
    }

    .wall-panel-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 4px;
    }

    .wall-panel-head .label {
      margin-bottom: 0;
    }

    .help-btn {
      width: 24px;
      height: 24px;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 0;
      border: 1px solid var(--control-border);
      border-radius: 999px;
      background: #fff;
      color: #15437c;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 700;
      line-height: 1;
    }

    .help-btn:hover {
      background: #edf4ff;
      border-color: #83abd9;
    }

    .help-wrap {
      position: relative;
      display: inline-flex;
      align-items: center;
    }

    .help-popup {
      position: absolute;
      right: calc(100% + 8px);
      top: 50%;
      transform: translateY(-50%);
      background: #fff;
      border: 1px solid var(--control-border);
      border-radius: 8px;
      box-shadow: var(--shadow);
      color: var(--text);
      font-size: 0.72rem;
      font-weight: 600;
      line-height: 1.2;
      padding: 4px 8px;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      transition: opacity 120ms ease;
      z-index: 8;
    }

    .help-wrap:hover .help-popup,
    .help-wrap:focus-within .help-popup {
      opacity: 1;
      visibility: visible;
    }

    .wall-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.82rem;
      color: var(--muted);
    }

    .wall-item select {
      flex: 1;
      min-width: 0;
    }

    .wall-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    #randomParkingRow,
    #randomStartZoneRow {
      margin-top: 6px;
    }

    .check-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.82rem;
      color: var(--text);
      font-weight: 600;
      user-select: none;
    }

    .check-item input[type="checkbox"] {
      margin: 0;
      width: 14px;
      height: 14px;
      accent-color: #0b438f;
    }

    .mini-btn {
      border: 1px solid var(--control-border);
      border-radius: 8px;
      background: #fff;
      color: var(--text);
      cursor: pointer;
      font-size: 0.82rem;
      padding: 4px 10px;
    }

    .size-btn:hover,
    .clear-btn:hover,
    .mini-btn:hover {
      background: #edf4ff;
      border-color: #83abd9;
    }

    select:disabled,
    .mini-btn:disabled {
      background: #e9f0fb;
      border-color: #c4d3e8;
      color: #6b7f9a;
      cursor: not-allowed;
    }

    .wall-note {
      margin: 6px 0 0;
      font-size: 0.78rem;
      color: #3f5878;
      line-height: 1.3;
    }

    .zone-value {
      font-size: 0.84rem;
      color: var(--text);
      font-variant-numeric: tabular-nums;
      font-weight: 700;
    }

    @media (max-width: 920px) {
      .workspace {
        grid-template-columns: 1fr;
        gap: 10px;
      }

      .left-col {
        width: 100%;
      }

      .board {
        width: min(100%, var(--board-max));
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <div class="workspace">
      <div class="left-col">
        <section class="board" id="board">
          <img id="fieldImage" src="field-web.png" alt="Field map" />
          <svg class="wall-overlay" id="wallOverlay" aria-hidden="true"></svg>
          <div class="cross v" id="crossV"></div>
          <div class="cross h" id="crossH"></div>
          <svg class="lines-layer" id="linesLayer" aria-hidden="true"></svg>
          <div class="points-layer" id="pointsLayer"></div>
          <div class="start-zone-layer" id="startZoneLayer"></div>
        </section>

        <div class="size-mode" id="sizeMode">
          <span class="label">Size</span>
          <div class="size-buttons">
            <button type="button" class="size-btn active" data-size="s">S</button>
            <button type="button" class="size-btn" data-size="m">M</button>
            <button type="button" class="size-btn" data-size="l">L</button>
          </div>
        </div>
      </div>

      <aside class="right-col">
        <div class="control">
          <label for="modeSelect" class="label">Mode</label>
          <select id="modeSelect">
            <option value="open" selected>Open Challenge</option>
            <option value="obstacle">Obstacle Challenge</option>
            <option value="obstacle_manual">Obstacle Challenge (manual)</option>
          </select>
        </div>

        <div class="control">
          <div class="wall-panel-head">
            <div class="label" id="wallConfigLabel">Open Challenge Settings</div>
            <div class="help-wrap">
              <button type="button" class="help-btn" id="obstacleRulesBtn" aria-label="Open obstacle challenge rules page 15" title="36 cards with pisitions">?</button>
              <div class="help-popup">36 cards with pisitions</div>
            </div>
          </div>
          <div class="wall-grid" id="wallGrid">
            <label class="wall-item">Top
              <select id="wallTopSelect">
                <option value="1" selected>1000 mm</option>
                <option value="0.6">600 mm</option>
              </select>
            </label>
            <label class="wall-item">Right
              <select id="wallRightSelect">
                <option value="1" selected>1000 mm</option>
                <option value="0.6">600 mm</option>
              </select>
            </label>
            <label class="wall-item">Bottom
              <select id="wallBottomSelect">
                <option value="1" selected>1000 mm</option>
                <option value="0.6">600 mm</option>
              </select>
            </label>
            <label class="wall-item">Left
              <select id="wallLeftSelect">
                <option value="1" selected>1000 mm</option>
                <option value="0.6">600 mm</option>
              </select>
            </label>
          </div>
          <div class="wall-row">
            <button type="button" class="mini-btn" id="randomWallsBtn">Random Toss</button>
            <button type="button" class="mini-btn" id="randomStartZoneBtn">Random Start Zone</button>
            <button type="button" class="mini-btn" id="randomDirectionBtn">Random Direction</button>
            <button type="button" class="mini-btn" id="randomObstaclesBtn" style="display: none;">Random Obstacles</button>
            <button type="button" class="mini-btn" id="clearObstaclesBtn" style="display: none;">Clear Obstacles</button>
          </div>
          <div class="wall-row" id="randomParkingRow" style="display: none;">
            <label class="check-item">
              <input type="checkbox" id="randomParkingCheck" />
              <span>Random Parking</span>
            </label>
          </div>
          <div class="wall-row" id="randomStartZoneRow" style="display: none;">
            <label class="check-item">
              <input type="checkbox" id="randomStartZoneCheck" />
              <span>Random Start Zone</span>
            </label>
          </div>
          <div class="wall-row">
            <span class="zone-value" id="startZoneValue">Bottom start zone: -</span>
            <span class="zone-value" id="directionValue">Direction: -</span>
          </div>
          <p class="wall-note" id="wallNote">Per rules: each section is wide (1000 mm) or narrow (600 mm).</p>
          <p class="wall-note" id="obstacleCardsInfo"></p>
        </div>

        <div class="control-row">
          <div class="control">
            <label for="unitSelect" class="label">Units</label>
            <select id="unitSelect">
              <option value="mm" selected>Millimeters (mm)</option>
              <option value="cm">Centimeters (cm)</option>
              <option value="m">Meters (m)</option>
            </select>
          </div>

          <div class="control">
            <label for="snapSelect" class="label">Snap Grid (Invisible)</label>
            <select id="snapSelect">
              <option value="off">Off</option>
              <option value="0.01">10 mm</option>
              <option value="0.05">50 mm</option>
              <option value="0.1" selected>100 mm</option>
            </select>
          </div>
        </div>

        <div class="stat">
          <div class="label">Live (x, y)</div>
          <div class="value" id="liveValue">x: -, y: -</div>
        </div>

        <div class="stat">
          <div class="label">Locked (x, y)</div>
          <div class="value" id="lockedValue">x: -, y: -</div>
        </div>

        <div class="control">
          <div class="label">Points</div>
          <div class="points-header">
            <span class="points-count" id="pointsCount">0 points</span>
            <button type="button" class="clear-btn" id="clearPointsBtn">Clear</button>
          </div>
          <ol class="points-list" id="pointsList"></ol>
        </div>
      </aside>
    </div>
  </main>

  <script>
    (function () {
      var FIELD_SIZE_M = 3.2;
      var COORD_MIN_M = -0.1;
      var COORD_SPAN_M = FIELD_SIZE_M;
      var INNER_WALL_THICKNESS_M = 0.02;
      var OPEN_WALL_WIDE_M = 1.0;
      var OPEN_WALL_NARROW_M = 0.6;
      var OPEN_START_DEFAULT_SIDE = "bottom";
      var OPEN_START_SIDES = ["top", "right", "bottom", "left"];
      var OBSTACLE_BOUNDARY_WIDTH_M = 0.02;
      var OBSTACLE_BOUNDARY_LENGTH_M = 0.2;
      var OBSTACLE_PARKING_DEFAULT_SIDE = "bottom";
      var OBSTACLE_PARKING_SIDES = ["top", "right", "bottom", "left"];
      var OBSTACLE_PARKING_SIDE_TURNS = {
        bottom: 0,
        right: 1,
        top: 2,
        left: 3
      };
      var OBSTACLE_PARKING_BASE_LINES = [
        { x1: 1.6, y1: 0.0, x2: 1.6, y2: OBSTACLE_BOUNDARY_LENGTH_M },
        { x1: 2.0, y1: 0.0, x2: 2.0, y2: OBSTACLE_BOUNDARY_LENGTH_M }
      ];
      var OBSTACLE_PARKING_BASE_ARROW = { x: 1.8, y: 0.1 };
      var PARKING_SAFE_INTERSECTION_MAP = {
        T3: "T1",
        T4: "T2",
        X2: "X1"
      };
      var SINGLE_SIGN_SIZE_M = 0.05;
      var SINGLE_SIGN_POSITIONS = [
        { name: "top", intersection: "X2", x: 1.5, y: 2.6 },
        { name: "right", intersection: "X2", x: 2.6, y: 1.5 },
        { name: "bottom", intersection: "X1", x: 1.5, y: 0.6 },
        { name: "left", intersection: "X2", x: 0.4, y: 1.5 }
      ];
      var OBSTACLE_INTERSECTION_COORDS_M = {
        top: {
          T4: { x: 1.0, y: 2.6 },
          X2: { x: 1.5, y: 2.6 },
          T3: { x: 2.0, y: 2.6 },
          T2: { x: 1.0, y: 2.4 },
          X1: { x: 1.5, y: 2.4 },
          T1: { x: 2.0, y: 2.4 }
        },
        right: {
          T4: { x: 2.6, y: 2.0 },
          X2: { x: 2.6, y: 1.5 },
          T3: { x: 2.6, y: 1.0 },
          T2: { x: 2.4, y: 2.0 },
          X1: { x: 2.4, y: 1.5 },
          T1: { x: 2.4, y: 1.0 }
        },
        bottom: {
          T4: { x: 2.0, y: 0.4 },
          X2: { x: 1.5, y: 0.4 },
          T3: { x: 1.0, y: 0.4 },
          T2: { x: 2.0, y: 0.6 },
          X1: { x: 1.5, y: 0.6 },
          T1: { x: 1.0, y: 0.6 }
        },
        left: {
          T4: { x: 0.4, y: 1.0 },
          X2: { x: 0.4, y: 1.5 },
          T3: { x: 0.4, y: 2.0 },
          T2: { x: 0.6, y: 1.0 },
          X1: { x: 0.6, y: 1.5 },
          T1: { x: 0.6, y: 2.0 }
        }
      };
      var TRACK_MIN_M = 0.0;
      var TRACK_MAX_M = 3.0;
      var UNIT_CONFIG = {
        m: { factor: 1, decimals: 3, label: "m" },
        cm: { factor: 100, decimals: 1, label: "cm" },
        mm: { factor: 1000, decimals: 0, label: "mm" }
      };

      var board = document.getElementById("board");
      var fieldImage = document.getElementById("fieldImage");
      var liveValue = document.getElementById("liveValue");
      var lockedValue = document.getElementById("lockedValue");
      var modeSelect = document.getElementById("modeSelect");
      var unitSelect = document.getElementById("unitSelect");
      var snapSelect = document.getElementById("snapSelect");
      var wallOverlay = document.getElementById("wallOverlay");
      var crossV = document.getElementById("crossV");
      var crossH = document.getElementById("crossH");
      var linesLayer = document.getElementById("linesLayer");
      var pointsLayer = document.getElementById("pointsLayer");
      var startZoneLayer = document.getElementById("startZoneLayer");
      var leftCol = document.querySelector(".left-col");
      var sizeMode = document.getElementById("sizeMode");
      var pointsCount = document.getElementById("pointsCount");
      var pointsList = document.getElementById("pointsList");
      var clearPointsBtn = document.getElementById("clearPointsBtn");
      var wallTopSelect = document.getElementById("wallTopSelect");
      var wallRightSelect = document.getElementById("wallRightSelect");
      var wallBottomSelect = document.getElementById("wallBottomSelect");
      var wallLeftSelect = document.getElementById("wallLeftSelect");
      var wallGrid = document.getElementById("wallGrid");
      var randomWallsBtn = document.getElementById("randomWallsBtn");
      var randomStartZoneBtn = document.getElementById("randomStartZoneBtn");
      var randomDirectionBtn = document.getElementById("randomDirectionBtn");
      var randomParkingRow = document.getElementById("randomParkingRow");
      var randomParkingCheck = document.getElementById("randomParkingCheck");
      var randomObstaclesBtn = document.getElementById("randomObstaclesBtn");
      var clearObstaclesBtn = document.getElementById("clearObstaclesBtn");
      var randomStartZoneRow = document.getElementById("randomStartZoneRow");
      var randomStartZoneCheck = document.getElementById("randomStartZoneCheck");
      var wallConfigLabel = document.getElementById("wallConfigLabel");
      var wallNote = document.getElementById("wallNote");
      var obstacleCardsInfo = document.getElementById("obstacleCardsInfo");
      var obstacleRulesBtn = document.getElementById("obstacleRulesBtn");
      var startZoneValue = document.getElementById("startZoneValue");
      var directionValue = document.getElementById("directionValue");

      var SIZE_CONFIG = {
        s: "clamp(300px, 44vw, 560px)",
        m: "clamp(420px, 58vw, 760px)",
        l: "clamp(520px, 72vw, 980px)"
      };

      var BOTTOM_START_ZONES = [
        { zone: 1, xMin: 1.5, yMin: 0.6, xMax: 2.0, yMax: 1.0 },
        { zone: 2, xMin: 1.5, yMin: 0.4, xMax: 2.0, yMax: 0.6 },
        { zone: 3, xMin: 1.5, yMin: 0.0, xMax: 2.0, yMax: 0.4 },
        { zone: 4, xMin: 1.0, yMin: 0.6, xMax: 1.5, yMax: 1.0 },
        { zone: 5, xMin: 1.0, yMin: 0.4, xMax: 1.5, yMax: 0.6 },
        { zone: 6, xMin: 1.0, yMin: 0.0, xMax: 1.5, yMax: 0.4 }
      ];

      // Full 36-card dataset (official card ids are 1..36, with repeated layouts).
      // Each placement is inside one straightforward section using intersection labels:
      // T1, X1, T2, T3, X2, T4
      var CARDS36 = [
        { id: 1, placements: [{ intersection: "T1", color: "green" }] },
        { id: 2, placements: [{ intersection: "T1", color: "red" }] },
        { id: 3, placements: [{ intersection: "X1", color: "green" }] },
        { id: 4, placements: [{ intersection: "X1", color: "red" }] },
        { id: 5, placements: [{ intersection: "T2", color: "green" }] },
        { id: 6, placements: [{ intersection: "T2", color: "red" }] },
        { id: 7, placements: [{ intersection: "T3", color: "green" }] },
        { id: 8, placements: [{ intersection: "T3", color: "red" }] },
        { id: 9, placements: [{ intersection: "X2", color: "green" }] },
        { id: 10, placements: [{ intersection: "X2", color: "red" }] },
        { id: 11, placements: [{ intersection: "T4", color: "green" }] },
        { id: 12, placements: [{ intersection: "T4", color: "red" }] },
        { id: 13, placements: [
          { intersection: "T3", color: "green" },
          { intersection: "T2", color: "green" }
        ] },
        { id: 14, placements: [
          { intersection: "T3", color: "green" },
          { intersection: "T2", color: "red" }
        ] },
        { id: 15, placements: [
          { intersection: "T3", color: "red" },
          { intersection: "T2", color: "green" }
        ] },
        { id: 16, placements: [
          { intersection: "T3", color: "green" },
          { intersection: "T2", color: "red" }
        ] },
        { id: 17, placements: [
          { intersection: "T3", color: "red" },
          { intersection: "T2", color: "green" }
        ] },
        { id: 18, placements: [
          { intersection: "T3", color: "red" },
          { intersection: "T2", color: "red" }
        ] },
        { id: 19, placements: [
          { intersection: "T1", color: "green" },
          { intersection: "T4", color: "green" }
        ] },
        { id: 20, placements: [
          { intersection: "T1", color: "green" },
          { intersection: "T4", color: "red" }
        ] },
        { id: 21, placements: [
          { intersection: "T1", color: "red" },
          { intersection: "T4", color: "green" }
        ] },
        { id: 22, placements: [
          { intersection: "T1", color: "green" },
          { intersection: "T4", color: "red" }
        ] },
        { id: 23, placements: [
          { intersection: "T1", color: "red" },
          { intersection: "T4", color: "green" }
        ] },
        { id: 24, placements: [
          { intersection: "T1", color: "red" },
          { intersection: "T4", color: "red" }
        ] },
        { id: 25, placements: [
          { intersection: "T1", color: "green" },
          { intersection: "T2", color: "green" }
        ] },
        { id: 26, placements: [
          { intersection: "T1", color: "green" },
          { intersection: "T2", color: "red" }
        ] },
        { id: 27, placements: [
          { intersection: "T1", color: "red" },
          { intersection: "T2", color: "green" }
        ] },
        { id: 28, placements: [
          { intersection: "T1", color: "green" },
          { intersection: "T2", color: "red" }
        ] },
        { id: 29, placements: [
          { intersection: "T1", color: "red" },
          { intersection: "T2", color: "green" }
        ] },
        { id: 30, placements: [
          { intersection: "T1", color: "red" },
          { intersection: "T2", color: "red" }
        ] },
        { id: 31, placements: [
          { intersection: "T3", color: "green" },
          { intersection: "T4", color: "green" }
        ] },
        { id: 32, placements: [
          { intersection: "T3", color: "green" },
          { intersection: "T4", color: "red" }
        ] },
        { id: 33, placements: [
          { intersection: "T3", color: "red" },
          { intersection: "T4", color: "green" }
        ] },
        { id: 34, placements: [
          { intersection: "T3", color: "green" },
          { intersection: "T4", color: "red" }
        ] },
        { id: 35, placements: [
          { intersection: "T3", color: "red" },
          { intersection: "T4", color: "green" }
        ] },
        { id: 36, placements: [
          { intersection: "T3", color: "red" },
          { intersection: "T4", color: "red" }
        ] }
      ];

      var lastHoverNorm = null;
      var lastHoverRawNorm = null;
      var hoverVisible = false;
      var points = [];
      var startZone = null;
      var driveDirection = null;
      var singleTrafficSign = null;
      var obstacleCardScheme = null;
      var manualObstacleSigns = [];
      var obstacleParkingSide = OBSTACLE_PARKING_DEFAULT_SIDE;
      var challengeMode = "";
      var savedOpenWallValues = {
        top: String(OPEN_WALL_WIDE_M),
        right: String(OPEN_WALL_WIDE_M),
        bottom: String(OPEN_WALL_WIDE_M),
        left: String(OPEN_WALL_WIDE_M)
      };
      var startZoneRectEl = document.createElement("div");
      var startDirArrowEl = document.createElement("div");
      var obstacleDirArrowEl = document.createElement("div");
      var singleTrafficSignEl = document.createElement("div");
      var obstacleCardSignEls = [];
      startZoneRectEl.className = "start-zone-rect";
      startDirArrowEl.className = "start-dir-arrow";
      obstacleDirArrowEl.className = "start-dir-arrow";
      singleTrafficSignEl.className = "single-traffic-sign";
      startZoneRectEl.appendChild(startDirArrowEl);
      startZoneLayer.appendChild(startZoneRectEl);
      startZoneLayer.appendChild(obstacleDirArrowEl);
      startZoneLayer.appendChild(singleTrafficSignEl);
      setStartZoneVisible(false);
      obstacleDirArrowEl.style.display = "none";
      obstacleCardsInfo.style.display = "none";

      function setStartZoneVisible(visible) {
        startZoneRectEl.style.display = visible ? "flex" : "none";
      }

      function clamp(v, min, max) {
        return Math.min(Math.max(v, min), max);
      }

      function toMeters(normX, normY) {
        var x = COORD_MIN_M + normX * COORD_SPAN_M;
        var y = COORD_MIN_M + (1 - normY) * COORD_SPAN_M;
        return { x: x, y: y };
      }

      function fromMeters(x, y) {
        var normX = (x - COORD_MIN_M) / COORD_SPAN_M;
        var normY = 1 - (y - COORD_MIN_M) / COORD_SPAN_M;
        return {
          normX: clamp(normX, 0, 1),
          normY: clamp(normY, 0, 1)
        };
      }

      function getActiveUnit() {
        return UNIT_CONFIG[unitSelect.value] || UNIT_CONFIG.mm;
      }

      function formatPoint(point) {
        var unit = getActiveUnit();
        var xValue = point.x * unit.factor;
        var yValue = point.y * unit.factor;
        return "x: " + xValue.toFixed(unit.decimals) + " " + unit.label + ", y: " + yValue.toFixed(unit.decimals) + " " + unit.label;
      }

      function getSnapStepM() {
        var value = parseFloat(snapSelect.value);
        if (!Number.isFinite(value) || value <= 0) {
          return 0;
        }
        return value;
      }

      function snapNorm(norm) {
        var stepM = getSnapStepM();
        if (stepM <= 0) {
          return clamp(norm, 0, 1);
        }
        var stepNorm = stepM / COORD_SPAN_M;
        if (stepNorm <= 0) {
          return clamp(norm, 0, 1);
        }
        return clamp(Math.round(norm / stepNorm) * stepNorm, 0, 1);
      }

      function applySnap(normX, normY) {
        return {
          normX: snapNorm(normX),
          normY: snapNorm(normY)
        };
      }

      function getBoardMetrics() {
        var rect = board.getBoundingClientRect();
        var width = board.clientWidth;
        var height = board.clientHeight;
        if (!width || !height) {
          return null;
        }
        return {
          left: rect.left + board.clientLeft,
          top: rect.top + board.clientTop,
          width: width,
          height: height
        };
      }

      function parseWallDistance(selectEl) {
        var v = parseFloat(selectEl.value);
        if (!Number.isFinite(v) || v <= 0) {
          return OPEN_WALL_WIDE_M;
        }
        return v;
      }

      function getWallDistances() {
        return {
          top: parseWallDistance(wallTopSelect),
          right: parseWallDistance(wallRightSelect),
          bottom: parseWallDistance(wallBottomSelect),
          left: parseWallDistance(wallLeftSelect)
        };
      }

      function getWallValues() {
        return {
          top: wallTopSelect.value,
          right: wallRightSelect.value,
          bottom: wallBottomSelect.value,
          left: wallLeftSelect.value
        };
      }

      function setWallValues(values) {
        wallTopSelect.value = values.top;
        wallRightSelect.value = values.right;
        wallBottomSelect.value = values.bottom;
        wallLeftSelect.value = values.left;
      }

      function setWallControlsDisabled(disabled) {
        [wallTopSelect, wallRightSelect, wallBottomSelect, wallLeftSelect].forEach(function (el) {
          el.disabled = disabled;
        });
      }

      function rotateParkingPointBySide(point, side) {
        var turns = OBSTACLE_PARKING_SIDE_TURNS[side];
        var t = Number.isFinite(turns) ? ((turns % 4) + 4) % 4 : 0;
        if (t === 0) {
          return { x: point.x, y: point.y };
        }
        if (t === 1) {
          return { x: TRACK_MAX_M - point.y, y: point.x };
        }
        if (t === 2) {
          return { x: TRACK_MAX_M - point.x, y: TRACK_MAX_M - point.y };
        }
        return { x: point.y, y: TRACK_MAX_M - point.x };
      }

      function getObstacleParkingLayout(side) {
        var safeSide = OBSTACLE_PARKING_SIDE_TURNS[side] != null ? side : OBSTACLE_PARKING_DEFAULT_SIDE;
        return {
          side: safeSide,
          arrow: rotateParkingPointBySide(OBSTACLE_PARKING_BASE_ARROW, safeSide),
          lines: OBSTACLE_PARKING_BASE_LINES.map(function (line) {
            var p1 = rotateParkingPointBySide({ x: line.x1, y: line.y1 }, safeSide);
            var p2 = rotateParkingPointBySide({ x: line.x2, y: line.y2 }, safeSide);
            return { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y };
          })
        };
      }

      function getObstacleDirectionAngle(side, direction) {
        var angleBySide = {
          bottom: { CW: 180, CCW: 0 },
          right: { CW: 90, CCW: 270 },
          top: { CW: 0, CCW: 180 },
          left: { CW: 270, CCW: 90 }
        };
        var bySide = angleBySide[side] || angleBySide.bottom;
        return bySide[direction] != null ? bySide[direction] : 0;
      }

      function randomizeObstacleParkingSide() {
        if (!randomParkingCheck.checked) {
          obstacleParkingSide = OBSTACLE_PARKING_DEFAULT_SIDE;
          return;
        }
        obstacleParkingSide = OBSTACLE_PARKING_SIDES[Math.floor(Math.random() * OBSTACLE_PARKING_SIDES.length)];
      }

      function getRandomOpenStartSide() {
        if (!randomStartZoneCheck.checked) {
          return OPEN_START_DEFAULT_SIDE;
        }
        return OPEN_START_SIDES[Math.floor(Math.random() * OPEN_START_SIDES.length)];
      }

      function rotateStartZoneFromBottom(zone, side) {
        var p1 = rotateParkingPointBySide({ x: zone.xMin, y: zone.yMin }, side);
        var p2 = rotateParkingPointBySide({ x: zone.xMax, y: zone.yMax }, side);
        return {
          xMin: Math.min(p1.x, p2.x),
          yMin: Math.min(p1.y, p2.y),
          xMax: Math.max(p1.x, p2.x),
          yMax: Math.max(p1.y, p2.y)
        };
      }

      function isStartZoneValidForSide(zone, side) {
        if (!zone) {
          return false;
        }
        var d = getWallDistances();
        var s = side || OPEN_START_DEFAULT_SIDE;
        var eps = 1e-9;
        if (s === "bottom") {
          return zone.yMax <= d.bottom + eps;
        }
        if (s === "top") {
          return zone.yMin >= TRACK_MAX_M - d.top - eps;
        }
        if (s === "left") {
          return zone.xMax <= d.left + eps;
        }
        if (s === "right") {
          return zone.xMin >= TRACK_MAX_M - d.right - eps;
        }
        return false;
      }

      function updateObstacleDirectionArrow(metricsArg) {
        var m = metricsArg || getBoardMetrics();
        var isObstacleMode = challengeMode === "obstacle" || challengeMode === "obstacle_manual";
        if (!isObstacleMode || !driveDirection || !m) {
          obstacleDirArrowEl.style.display = "none";
          return;
        }
        var parkingLayout = getObstacleParkingLayout(obstacleParkingSide);
        var norm = fromMeters(parkingLayout.arrow.x, parkingLayout.arrow.y);
        obstacleDirArrowEl.style.left = (norm.normX * m.width).toFixed(2) + "px";
        obstacleDirArrowEl.style.top = (norm.normY * m.height).toFixed(2) + "px";
        obstacleDirArrowEl.style.display = "block";
        obstacleDirArrowEl.style.transform = "translate(-50%, -50%) rotate(" + getObstacleDirectionAngle(parkingLayout.side, driveDirection) + "deg)";
      }

      function updateSingleTrafficSignOverlay(metricsArg) {
        var m = metricsArg || getBoardMetrics();
        if (challengeMode !== "obstacle" || !singleTrafficSign || !m) {
          singleTrafficSignEl.style.display = "none";
          return;
        }
        var signX = singleTrafficSign.x;
        var signY = singleTrafficSign.y;
        if (singleTrafficSign.side === obstacleParkingSide && singleTrafficSign.intersection) {
          var safeIntersection = getParkingSafeIntersection(singleTrafficSign.side, singleTrafficSign.intersection);
          var safePoint = getObstacleIntersectionPoint(singleTrafficSign.side, safeIntersection);
          if (safePoint) {
            signX = safePoint.x;
            signY = safePoint.y;
          }
        }
        var norm = fromMeters(signX, signY);
        var sizePx = Math.max(4, (SINGLE_SIGN_SIZE_M / FIELD_SIZE_M) * Math.min(m.width, m.height));
        singleTrafficSignEl.style.left = (norm.normX * m.width).toFixed(2) + "px";
        singleTrafficSignEl.style.top = (norm.normY * m.height).toFixed(2) + "px";
        singleTrafficSignEl.style.width = sizePx.toFixed(2) + "px";
        singleTrafficSignEl.style.height = sizePx.toFixed(2) + "px";
        singleTrafficSignEl.classList.toggle("red", singleTrafficSign.color === "red");
        singleTrafficSignEl.classList.toggle("green", singleTrafficSign.color === "green");
        singleTrafficSignEl.style.display = "block";
      }

      function randomizeOpenWalls() {
        var values = [String(OPEN_WALL_WIDE_M), String(OPEN_WALL_NARROW_M)];
        wallTopSelect.value = values[Math.floor(Math.random() * 2)];
        wallRightSelect.value = values[Math.floor(Math.random() * 2)];
        wallBottomSelect.value = values[Math.floor(Math.random() * 2)];
        wallLeftSelect.value = values[Math.floor(Math.random() * 2)];
      }

      function capitalizeWord(text) {
        if (!text) {
          return "";
        }
        return text.charAt(0).toUpperCase() + text.slice(1);
      }

      function getClockwiseSidesFrom(startSide) {
        var order = ["top", "right", "bottom", "left"];
        var idx = order.indexOf(startSide);
        if (idx < 0) {
          idx = 0;
        }
        return [
          order[idx],
          order[(idx + 1) % 4],
          order[(idx + 2) % 4],
          order[(idx + 3) % 4]
        ];
      }

      function drawCardIdsWithoutReplacement(excludedCardIds, amount) {
        var deck = CARDS36
          .map(function (card) { return card.id; })
          .filter(function (id) { return excludedCardIds.indexOf(id) < 0; });
        var chosen = [];
        var count = Math.min(amount, deck.length);
        while (chosen.length < count) {
          var idx = Math.floor(Math.random() * deck.length);
          chosen.push(deck[idx]);
          deck.splice(idx, 1);
        }
        return chosen;
      }

      function ensureObstacleCardSignEls(count) {
        while (obstacleCardSignEls.length < count) {
          var el = document.createElement("div");
          el.className = "single-traffic-sign";
          el.style.display = "none";
          startZoneLayer.appendChild(el);
          obstacleCardSignEls.push(el);
        }
      }

      function hideObstacleCardSigns() {
        obstacleCardSignEls.forEach(function (el) {
          el.style.display = "none";
        });
      }

      function getObstacleIntersectionPoint(side, intersection) {
        var sideMap = OBSTACLE_INTERSECTION_COORDS_M[side];
        if (!sideMap) {
          return null;
        }
        return sideMap[intersection] || null;
      }

      function getParkingSafeIntersection(side, intersection) {
        if (side !== obstacleParkingSide) {
          return intersection;
        }
        return PARKING_SAFE_INTERSECTION_MAP[intersection] || intersection;
      }

      function collectObstacleCardSigns() {
        if (challengeMode === "obstacle_manual") {
          return manualObstacleSigns.map(function (sign) {
            return { x: sign.x, y: sign.y, color: sign.color };
          });
        }
        if (!obstacleCardScheme) {
          return [];
        }
        var signs = [];
        obstacleCardScheme.assignments.forEach(function (assignment) {
          assignment.placements.forEach(function (placement) {
            var safeIntersection = getParkingSafeIntersection(assignment.side, placement.intersection);
            var point = getObstacleIntersectionPoint(assignment.side, safeIntersection);
            if (!point) {
              return;
            }
            signs.push({
              x: point.x,
              y: point.y,
              color: placement.color
            });
          });
        });
        return signs;
      }

      function updateObstacleCardSignsOverlay(metricsArg) {
        var m = metricsArg || getBoardMetrics();
        var isObstacleMode = challengeMode === "obstacle" || challengeMode === "obstacle_manual";
        if (!isObstacleMode || !m) {
          hideObstacleCardSigns();
          return;
        }
        if (challengeMode === "obstacle" && !obstacleCardScheme) {
          hideObstacleCardSigns();
          return;
        }

        var signs = collectObstacleCardSigns();
        var sizePx = Math.max(4, (SINGLE_SIGN_SIZE_M / FIELD_SIZE_M) * Math.min(m.width, m.height));
        ensureObstacleCardSignEls(signs.length);
        obstacleCardSignEls.forEach(function (el, idx) {
          if (idx >= signs.length) {
            el.style.display = "none";
            return;
          }
          var sign = signs[idx];
          var norm = fromMeters(sign.x, sign.y);
          el.style.left = (norm.normX * m.width).toFixed(2) + "px";
          el.style.top = (norm.normY * m.height).toFixed(2) + "px";
          el.style.width = sizePx.toFixed(2) + "px";
          el.style.height = sizePx.toFixed(2) + "px";
          el.classList.toggle("red", sign.color === "red");
          el.classList.toggle("green", sign.color === "green");
          el.style.display = "block";
        });
      }

      function updateObstacleCardsInfo() {
        if (challengeMode !== "obstacle" || !obstacleCardScheme) {
          obstacleCardsInfo.style.display = "none";
          obstacleCardsInfo.innerHTML = "";
          return;
        }

        var singleInfo = "Single section: " + capitalizeWord(obstacleCardScheme.singleSection) +
          " -> Card " + obstacleCardScheme.singleCardId;
        var cardsInfo = obstacleCardScheme.assignments.map(function (item) {
          return capitalizeWord(item.side) + " -> Card " + item.cardId;
        }).join(", ");
        obstacleCardsInfo.innerHTML = singleInfo + "<br>Clockwise cards: " + cardsInfo + ".";
        obstacleCardsInfo.style.display = "block";
      }

      function randomizeObstacleCards() {
        randomizeObstacleParkingSide();
        var point = SINGLE_SIGN_POSITIONS[Math.floor(Math.random() * SINGLE_SIGN_POSITIONS.length)];
        var color = Math.random() < 0.5 ? "green" : "red";
        singleTrafficSign = {
          side: point.name,
          intersection: point.intersection,
          x: point.x,
          y: point.y,
          color: color
        };

        var singleCardId = color === "green" ? 9 : 10;
        var clockwiseSides = getClockwiseSidesFrom(point.name);
        var remainingSides = [clockwiseSides[1], clockwiseSides[2], clockwiseSides[3]];
        var drawnCardIds = drawCardIdsWithoutReplacement([singleCardId], remainingSides.length);
        var assignments = remainingSides.map(function (side, idx) {
          var cardId = drawnCardIds[idx];
          var card = CARDS36.find(function (entry) { return entry.id === cardId; });
          return {
            side: side,
            cardId: cardId,
            placements: card ? card.placements : []
          };
        });
        obstacleCardScheme = {
          singleSection: point.name,
          singleColor: color,
          singleCardId: singleCardId,
          assignments: assignments
        };

        updateSingleTrafficSignOverlay();
        updateObstacleCardSignsOverlay();
        updateObstacleCardsInfo();
      }

      function findManualObstacleSignIndex(x, y) {
        var half = SINGLE_SIGN_SIZE_M * 0.5;
        var idx;
        for (idx = manualObstacleSigns.length - 1; idx >= 0; idx -= 1) {
          var sign = manualObstacleSigns[idx];
          if (Math.abs(sign.x - x) <= half && Math.abs(sign.y - y) <= half) {
            return idx;
          }
        }
        return -1;
      }

      function toggleManualObstacleSign(x, y, color) {
        var clampedX = clamp(x, TRACK_MIN_M, TRACK_MAX_M);
        var clampedY = clamp(y, TRACK_MIN_M, TRACK_MAX_M);
        var hitIdx = findManualObstacleSignIndex(clampedX, clampedY);
        if (hitIdx >= 0) {
          manualObstacleSigns.splice(hitIdx, 1);
          return;
        }
        manualObstacleSigns.push({
          x: clampedX,
          y: clampedY,
          color: color
        });
      }

      function applyChallengeMode(mode) {
        var nextMode = "open";
        if (mode === "obstacle") {
          nextMode = "obstacle";
        } else if (mode === "obstacle_manual") {
          nextMode = "obstacle_manual";
        }
        if (nextMode === challengeMode) {
          return;
        }

        if (challengeMode === "open" && nextMode !== "open") {
          savedOpenWallValues = getWallValues();
        }

        challengeMode = nextMode;
        modeSelect.value = challengeMode;

        if (challengeMode === "obstacle" || challengeMode === "obstacle_manual") {
          wallConfigLabel.textContent = "Obstacle Challenge Settings";
          if (challengeMode === "obstacle_manual") {
            wallConfigLabel.textContent = "Obstacle Challenge (manual) Settings";
          }
          wallNote.textContent = "";
          wallNote.style.display = "none";
          obstacleRulesBtn.style.display = "inline-flex";
          randomParkingRow.style.display = "flex";
          randomObstaclesBtn.style.display = challengeMode === "obstacle" ? "" : "none";
          clearObstaclesBtn.style.display = challengeMode === "obstacle_manual" ? "" : "none";
          randomStartZoneRow.style.display = "none";
          setWallValues({
            top: String(OPEN_WALL_WIDE_M),
            right: String(OPEN_WALL_WIDE_M),
            bottom: String(OPEN_WALL_WIDE_M),
            left: String(OPEN_WALL_WIDE_M)
          });
          setWallControlsDisabled(true);
          wallGrid.style.display = "none";
          randomStartZoneBtn.style.display = "none";
          startZoneValue.style.display = "none";
          randomizeObstacleParkingSide();
          if (challengeMode === "obstacle") {
            randomizeObstacleCards();
          } else {
            singleTrafficSignEl.style.display = "none";
            obstacleCardScheme = null;
            updateObstacleCardSignsOverlay();
            updateObstacleCardsInfo();
          }
        } else {
          wallConfigLabel.textContent = "Open Challenge Settings";
          wallNote.textContent = "Per rules: each section is wide (1000 mm) or narrow (600 mm).";
          wallNote.style.display = "block";
          obstacleRulesBtn.style.display = "none";
          randomParkingRow.style.display = "none";
          randomObstaclesBtn.style.display = "none";
          clearObstaclesBtn.style.display = "none";
          randomStartZoneRow.style.display = "flex";
          setWallValues(savedOpenWallValues);
          setWallControlsDisabled(false);
          wallGrid.style.display = "grid";
          randomStartZoneBtn.style.display = "";
          startZoneValue.style.display = "";
          singleTrafficSignEl.style.display = "none";
          obstacleCardScheme = null;
          updateObstacleCardSignsOverlay();
          updateObstacleCardsInfo();
        }

        updateWallOverlay();
        ensureStartZoneValid();
      }

      function getZoneByDie(dieFace) {
        return BOTTOM_START_ZONES[dieFace - 1] || null;
      }

      function randomizeDirection() {
        driveDirection = Math.random() < 0.5 ? "CW" : "CCW";
        updateDirectionUi();
      }

      function updateDirectionUi() {
        directionValue.textContent = "Direction: " + (driveDirection || "-");
        if (challengeMode === "obstacle" || challengeMode === "obstacle_manual") {
          startDirArrowEl.style.display = "none";
          updateObstacleDirectionArrow();
          return;
        }

        obstacleDirArrowEl.style.display = "none";
        if (!driveDirection) {
          startDirArrowEl.style.display = "none";
          return;
        }
        var openSide = (startZone && startZone.side) ? startZone.side : OPEN_START_DEFAULT_SIDE;
        var openAngle = getObstacleDirectionAngle(openSide, driveDirection);
        startDirArrowEl.style.display = "block";
        startDirArrowEl.style.transform = "translate(-50%, -50%) rotate(" + openAngle + "deg)";
      }

      function updateStartZoneOverlay() {
        if (challengeMode === "obstacle" || challengeMode === "obstacle_manual") {
          setStartZoneVisible(false);
          startZoneValue.textContent = "Bottom start zone: -";
          var obstacleMetrics = getBoardMetrics();
          updateObstacleDirectionArrow(obstacleMetrics);
          updateSingleTrafficSignOverlay(obstacleMetrics);
          updateObstacleCardSignsOverlay(obstacleMetrics);
          updateObstacleCardsInfo();
          return;
        }

        obstacleDirArrowEl.style.display = "none";
        singleTrafficSignEl.style.display = "none";
        updateObstacleCardSignsOverlay();
        updateObstacleCardsInfo();
        if (!startZone) {
          setStartZoneVisible(false);
          startZoneValue.textContent = randomStartZoneCheck.checked ? "Start zone: -" : "Bottom start zone: -";
          return;
        }
        var startSide = startZone.side || OPEN_START_DEFAULT_SIDE;
        startZoneValue.textContent = capitalizeWord(startSide) + " start zone: " + startZone.zone + " (die " + startZone.die + ")";

        var metrics = getBoardMetrics();
        if (!metrics) {
          setStartZoneVisible(false);
          return;
        }

        var normA = fromMeters(startZone.xMin, startZone.yMin);
        var normB = fromMeters(startZone.xMax, startZone.yMax);
        var leftPx = Math.min(normA.normX, normB.normX) * metrics.width;
        var rightPx = Math.max(normA.normX, normB.normX) * metrics.width;
        var topPx = Math.min(normA.normY, normB.normY) * metrics.height;
        var bottomPx = Math.max(normA.normY, normB.normY) * metrics.height;
        startZoneRectEl.style.left = leftPx + "px";
        startZoneRectEl.style.top = topPx + "px";
        startZoneRectEl.style.width = Math.max(0, rightPx - leftPx) + "px";
        startZoneRectEl.style.height = Math.max(0, bottomPx - topPx) + "px";
        updateDirectionUi();
        setStartZoneVisible(true);
      }

      function randomizeStartZone() {
        var maxAttempts = 32;
        var side = getRandomOpenStartSide();
        var attempt;
        for (attempt = 0; attempt < maxAttempts; attempt += 1) {
          var die = 1 + Math.floor(Math.random() * 6);
          var bottomZone = getZoneByDie(die);
          if (!bottomZone) {
            continue;
          }
          var zone = rotateStartZoneFromBottom(bottomZone, side);
          if (!isStartZoneValidForSide(zone, side)) {
            continue;
          }
          startZone = {
            die: die,
            zone: bottomZone.zone,
            side: side,
            xMin: zone.xMin,
            yMin: zone.yMin,
            xMax: zone.xMax,
            yMax: zone.yMax
          };
          updateStartZoneOverlay();
          return;
        }
        startZone = null;
        updateStartZoneOverlay();
      }

      function ensureStartZoneValid() {
        if (challengeMode === "obstacle" || challengeMode === "obstacle_manual") {
          setStartZoneVisible(false);
          updateStartZoneOverlay();
          return;
        }
        if (!startZone) {
          randomizeStartZone();
          return;
        }
        if (!randomStartZoneCheck.checked && (startZone.side || OPEN_START_DEFAULT_SIDE) !== OPEN_START_DEFAULT_SIDE) {
          randomizeStartZone();
          return;
        }
        if (!isStartZoneValidForSide(startZone, startZone.side || OPEN_START_DEFAULT_SIDE)) {
          randomizeStartZone();
          return;
        }
        updateStartZoneOverlay();
      }

      function updateWallOverlay(metrics) {
        var m = metrics || getBoardMetrics();
        if (!m) {
          return;
        }
        var d = getWallDistances();
        var leftM = TRACK_MIN_M + d.left;
        var rightM = TRACK_MAX_M - d.right;
        var topM = TRACK_MAX_M - d.top;
        var bottomM = TRACK_MIN_M + d.bottom;
        var x1 = fromMeters(leftM, TRACK_MIN_M).normX * m.width;
        var x2 = fromMeters(rightM, TRACK_MIN_M).normX * m.width;
        var y1 = fromMeters(TRACK_MIN_M, topM).normY * m.height;
        var y2 = fromMeters(TRACK_MIN_M, bottomM).normY * m.height;

        wallOverlay.setAttribute("viewBox", "0 0 " + m.width + " " + m.height);
        wallOverlay.innerHTML = "";
        if (x2 <= x1 || y2 <= y1) {
          return;
        }

        var wallPx = Math.max(1, (INNER_WALL_THICKNESS_M / FIELD_SIZE_M) * Math.min(m.width, m.height));
        var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("class", "inner-wall-path");
        path.setAttribute("stroke-width", wallPx.toFixed(2));
        path.setAttribute(
          "d",
          "M " + x1.toFixed(2) + " " + y1.toFixed(2) +
          " L " + x2.toFixed(2) + " " + y1.toFixed(2) +
          " L " + x2.toFixed(2) + " " + y2.toFixed(2) +
          " L " + x1.toFixed(2) + " " + y2.toFixed(2) + " Z"
        );
        wallOverlay.appendChild(path);

        if (challengeMode === "obstacle" || challengeMode === "obstacle_manual") {
          var boundaryPx = Math.max(1, (OBSTACLE_BOUNDARY_WIDTH_M / FIELD_SIZE_M) * Math.min(m.width, m.height));
          var parkingLayout = getObstacleParkingLayout(obstacleParkingSide);
          parkingLayout.lines.forEach(function (lineM) {
            var startNorm = fromMeters(lineM.x1, lineM.y1);
            var endNorm = fromMeters(lineM.x2, lineM.y2);
            var line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("class", "obstacle-boundary-line");
            line.setAttribute("stroke-width", boundaryPx.toFixed(2));
            line.setAttribute("x1", (startNorm.normX * m.width).toFixed(2));
            line.setAttribute("y1", (startNorm.normY * m.height).toFixed(2));
            line.setAttribute("x2", (endNorm.normX * m.width).toFixed(2));
            line.setAttribute("y2", (endNorm.normY * m.height).toFixed(2));
            wallOverlay.appendChild(line);
          });
        }
      }

      function ensureInitialWallOverlay(attemptsLeft) {
        if (getBoardMetrics()) {
          updateWallOverlay();
          return;
        }
        if (attemptsLeft <= 0) {
          return;
        }
        window.requestAnimationFrame(function () {
          ensureInitialWallOverlay(attemptsLeft - 1);
        });
      }

      function updateCrossFromNorm() {
        if (!hoverVisible || !lastHoverNorm) {
          return;
        }
        var metrics = getBoardMetrics();
        if (!metrics) {
          return;
        }
        var pxX = lastHoverNorm.normX * metrics.width;
        var pxY = lastHoverNorm.normY * metrics.height;
        showCross(pxX, pxY);
      }

      function setSizeMode(mode) {
        var key = SIZE_CONFIG[mode] ? mode : "s";
        leftCol.style.setProperty("--board-max", SIZE_CONFIG[key]);

        var buttons = sizeMode.querySelectorAll(".size-btn");
        buttons.forEach(function (btn) {
          btn.classList.toggle("active", btn.getAttribute("data-size") === key);
        });

        updateWallOverlay();
        updateCrossFromNorm();
        updatePointsFromNorm();
        updateStartZoneOverlay();
      }

      function getPointFromEvent(ev) {
        var metrics = getBoardMetrics();
        if (!metrics) {
          return null;
        }
        var pxX = clamp(ev.clientX - metrics.left, 0, metrics.width);
        var pxY = clamp(ev.clientY - metrics.top, 0, metrics.height);
        return {
          pxX: pxX,
          pxY: pxY,
          normX: pxX / metrics.width,
          normY: pxY / metrics.height,
          areaWidth: metrics.width,
          areaHeight: metrics.height
        };
      }

      function showCross(pxX, pxY) {
        crossV.style.left = pxX + "px";
        crossH.style.top = pxY + "px";
        crossV.classList.add("show");
        crossH.classList.add("show");
      }

      function hideCross() {
        crossV.classList.remove("show");
        crossH.classList.remove("show");
      }

      function updatePointsCount() {
        var total = points.length;
        pointsCount.textContent = total + (total === 1 ? " point" : " points");
      }

      function addPoint(normX, normY) {
        var point = {
          normX: normX,
          normY: normY,
          markerEl: document.createElement("div"),
          labelEl: document.createElement("div"),
          listEl: document.createElement("li")
        };
        point.markerEl.className = "point-marker";
        point.labelEl.className = "point-index";
        pointsLayer.appendChild(point.markerEl);
        pointsLayer.appendChild(point.labelEl);
        pointsList.appendChild(point.listEl);
        points.push(point);
      }

      function clearPoints() {
        points = [];
        linesLayer.innerHTML = "";
        pointsLayer.innerHTML = "";
        pointsList.innerHTML = "";
        lockedValue.textContent = "x: -, y: -";
        if (!hoverVisible) {
          hideCross();
        }
        updatePointsCount();
      }

      function updateLiveFromNorm() {
        if (!lastHoverNorm) {
          return;
        }
        var meters = toMeters(lastHoverNorm.normX, lastHoverNorm.normY);
        liveValue.textContent = formatPoint(meters);
      }

      function updateHoverFromRaw() {
        if (!lastHoverRawNorm) {
          return;
        }
        var snapped = applySnap(lastHoverRawNorm.normX, lastHoverRawNorm.normY);
        lastHoverNorm = { normX: snapped.normX, normY: snapped.normY };
        updateCrossFromNorm();
        updateLiveFromNorm();
      }

      function updatePointsFromNorm() {
        updatePointsCount();
        if (!points.length) {
          linesLayer.innerHTML = "";
          lockedValue.textContent = "x: -, y: -";
          if (!hoverVisible) {
            hideCross();
          }
          return;
        }
        var metrics = getBoardMetrics();
        if (!metrics) {
          return;
        }

        updateWallOverlay(metrics);
        updateStartZoneOverlay();
        linesLayer.setAttribute("viewBox", "0 0 " + metrics.width + " " + metrics.height);
        linesLayer.innerHTML = "";

        var lastPoint = points[points.length - 1];
        points.forEach(function (point, idx) {
          var pxX = point.normX * metrics.width;
          var pxY = point.normY * metrics.height;
          point.markerEl.style.left = pxX + "px";
          point.markerEl.style.top = pxY + "px";
          point.labelEl.style.left = pxX + "px";
          point.labelEl.style.top = pxY + "px";
          point.labelEl.textContent = String(idx + 1);
          point.markerEl.classList.toggle("latest", idx === points.length - 1);
          point.listEl.textContent = formatPoint(toMeters(point.normX, point.normY));

          if (idx > 0) {
            var prev = points[idx - 1];
            var line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("class", "point-link");
            line.setAttribute("x1", (prev.normX * metrics.width).toFixed(2));
            line.setAttribute("y1", (prev.normY * metrics.height).toFixed(2));
            line.setAttribute("x2", pxX.toFixed(2));
            line.setAttribute("y2", pxY.toFixed(2));
            linesLayer.appendChild(line);
          }
        });

        lockedValue.textContent = formatPoint(toMeters(lastPoint.normX, lastPoint.normY));
        if (!hoverVisible) {
          hideCross();
        }
      }

      function handlePointerMove(ev) {
        var point = getPointFromEvent(ev);
        if (!point) {
          return;
        }
        hoverVisible = true;
        lastHoverRawNorm = { normX: point.normX, normY: point.normY };
        var snapped = applySnap(point.normX, point.normY);
        lastHoverNorm = { normX: snapped.normX, normY: snapped.normY };
        showCross(snapped.normX * point.areaWidth, snapped.normY * point.areaHeight);
        updateLiveFromNorm();
      }

      function handlePointerLeave() {
        hoverVisible = false;
        updatePointsFromNorm();
      }

      function handlePointerDown(ev) {
        if (challengeMode === "obstacle_manual") {
          if (ev.button !== 0 && ev.button !== 2) {
            return;
          }
          ev.preventDefault();
          var manualPoint = getPointFromEvent(ev);
          if (!manualPoint) {
            return;
          }
          hoverVisible = true;
          lastHoverRawNorm = { normX: manualPoint.normX, normY: manualPoint.normY };
          var manualSnapped = applySnap(manualPoint.normX, manualPoint.normY);
          lastHoverNorm = { normX: manualSnapped.normX, normY: manualSnapped.normY };
          showCross(manualSnapped.normX * manualPoint.areaWidth, manualSnapped.normY * manualPoint.areaHeight);
          updateLiveFromNorm();
          var manualMeters = toMeters(manualSnapped.normX, manualSnapped.normY);
          toggleManualObstacleSign(manualMeters.x, manualMeters.y, ev.button === 2 ? "red" : "green");
          updateStartZoneOverlay();
          return;
        }
        var point = getPointFromEvent(ev);
        if (!point) {
          return;
        }
        hoverVisible = true;
        lastHoverRawNorm = { normX: point.normX, normY: point.normY };
        var snapped = applySnap(point.normX, point.normY);
        lastHoverNorm = { normX: snapped.normX, normY: snapped.normY };
        showCross(snapped.normX * point.areaWidth, snapped.normY * point.areaHeight);
        updateLiveFromNorm();
        addPoint(snapped.normX, snapped.normY);
        updatePointsFromNorm();
      }

      board.addEventListener("pointermove", handlePointerMove);
      board.addEventListener("pointerleave", handlePointerLeave);
      board.addEventListener("pointerdown", handlePointerDown);
      board.addEventListener("contextmenu", function (ev) {
        if (challengeMode === "obstacle_manual") {
          ev.preventDefault();
        }
      });
      sizeMode.addEventListener("click", function (ev) {
        var target = ev.target;
        if (!target.classList.contains("size-btn")) {
          return;
        }
        setSizeMode(target.getAttribute("data-size"));
      });

      clearPointsBtn.addEventListener("click", function () {
        clearPoints();
      });

      [wallTopSelect, wallRightSelect, wallBottomSelect, wallLeftSelect].forEach(function (el) {
        el.addEventListener("change", function () {
          if (challengeMode === "open") {
            savedOpenWallValues = getWallValues();
          }
          updateWallOverlay();
          ensureStartZoneValid();
        });
      });

      randomWallsBtn.addEventListener("click", function () {
        if (challengeMode === "open") {
          randomizeOpenWalls();
          savedOpenWallValues = getWallValues();
          updateWallOverlay();
          randomizeStartZone();
        } else if (challengeMode === "obstacle_manual") {
          randomizeObstacleParkingSide();
          updateWallOverlay();
        } else {
          randomizeObstacleCards();
          updateWallOverlay();
        }
        randomizeDirection();
        updateStartZoneOverlay();
      });

      randomStartZoneBtn.addEventListener("click", function () {
        randomizeStartZone();
      });

      randomDirectionBtn.addEventListener("click", function () {
        randomizeDirection();
      });

      randomObstaclesBtn.addEventListener("click", function () {
        if (challengeMode !== "obstacle") {
          return;
        }
        randomizeObstacleCards();
        updateWallOverlay();
        updateStartZoneOverlay();
      });

      clearObstaclesBtn.addEventListener("click", function () {
        if (challengeMode !== "obstacle_manual") {
          return;
        }
        manualObstacleSigns = [];
        updateStartZoneOverlay();
      });

      randomParkingCheck.addEventListener("change", function () {
        if (challengeMode !== "obstacle" && challengeMode !== "obstacle_manual") {
          return;
        }
        if (!randomParkingCheck.checked) {
          obstacleParkingSide = OBSTACLE_PARKING_DEFAULT_SIDE;
          updateWallOverlay();
          updateStartZoneOverlay();
        }
      });

      randomStartZoneCheck.addEventListener("change", function () {
        if (challengeMode !== "open") {
          return;
        }
        ensureStartZoneValid();
      });

      obstacleRulesBtn.addEventListener("click", function () {
        window.open("rules-obstacle-p15.png", "_blank", "noopener");
      });

      modeSelect.addEventListener("change", function () {
        applyChallengeMode(modeSelect.value);
      });

      unitSelect.addEventListener("change", function () {
        if (lastHoverNorm) {
          updateLiveFromNorm();
        }
        updatePointsFromNorm();
      });

      snapSelect.addEventListener("change", function () {
        updateHoverFromRaw();
      });

      window.addEventListener("resize", function () {
        updateWallOverlay();
        updateCrossFromNorm();
        updatePointsFromNorm();
        updateStartZoneOverlay();
      });

      fieldImage.addEventListener("load", function () {
        updateWallOverlay();
        updatePointsFromNorm();
        updateStartZoneOverlay();
      });

      setSizeMode("s");
      randomizeOpenWalls();
      savedOpenWallValues = getWallValues();
      randomizeStartZone();
      randomizeDirection();
      applyChallengeMode(modeSelect.value);
      updateWallOverlay();
      ensureInitialWallOverlay(40);
      updatePointsCount();
    })();
  </script>
</body>
</html>
